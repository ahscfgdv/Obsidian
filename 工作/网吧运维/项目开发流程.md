## 需求分析

**核心**：
搭建大模型和RAG，结合本地知识库回答客户的问题
**其他**：
1. 问题无法解决通知维护人员
2. 记录每次问题解决的流程补充知识库
3. 收集网吧机器的信息

## 技术选型

### 1. 系统架构图 (Conceptual)

- **Client (网吧终端):** 负责用户交互、硬件信息采集、问题上报。
    
- **Server (中心服务器):** 负责 AI 推理、RAG 检索、业务逻辑、通知分发。
    
- **Admin (运维管理端):** 这是一个 Web 端，供维护人员查看报警、管理知识库。
    

---

### 2. 详细技术选型清单

#### A. 客户端 (Client) - 网吧机器终端

需要运行在 Windows 上，且由于需要“收集机器信息”，原生应用比 Web 网页更合适。

- **GUI 框架:** **PyQt6 (或 PySide6)**
    
    - **理由:** 你需要开发 C/S 架构，PyQt 对 Windows 原生控件支持好，且 Python 有丰富的库（如 `psutil`, `WMI`）可以直接读取网卡、显卡、内存等硬件信息，这比用 Electron 调用底层 API 要简单得多。
        
- **打包工具:** **Nuitka**
    
    - **理由:** 网吧环境复杂，源码保护很重要。Nuitka 将 Python 编译为 C++ 代码再生成 exe，启动速度快，且难以被反编译，非常适合商业部署。
        
- **硬件监控:** **psutil + GPUtil**
    
    - **理由:** 用于获取 CPU、内存、磁盘、以及网吧最看重的**显卡(GPU)**状态。
        

#### B. 后端服务 (Server) - AI与业务中台

- **Web 框架:** **FastAPI**
    
    - **理由:** 高性能，原生支持异步（Async），非常适合处理 AI 模型的流式输出（Streaming Response），让用户感觉响应很快。
        
- **通信协议:** **HTTP (RESTful) + WebSocket**
    
    - **理由:** 常规请求用 HTTP；AI 对话使用 WebSocket，可以实现“打字机效果”，提升用户体验。
        

#### C. AI 与 RAG 核心 (The Brain)

这是项目的核心部分。

- **大模型编排:** **LangChain**
    
    - **理由:** 事实上的行业标准。你可以用它轻松构建“检索-增强-生成”的链路，管理 Prompt 和上下文历史。
        
- **向量数据库:** **FAISS (本地文件版) 或 ChromaDB**
    
    - **理由:** 考虑到知识库主要针对网吧业务，数据量不会达到亿级。FAISS 极其轻量，可以直接嵌入在服务端代码中，无需单独维护一个庞大的向量数据库服务。
        
- **Embedding 模型:** **BGE-M3 或 OpenAI text-embedding-3-small**
    
    - **理由:** 中文语义理解能力强，检索准确率高。
        
- **LLM 模型:**
    
    - _方案一 (云端):_ **DeepSeek V3 / Qwen-Max** (API 调用，成本低，速度快)。
        
    - _方案二 (私有化):_ **Ollama + Qwen2.5-14B** (如果网吧服务器显卡够好，可以本地部署，数据更安全)。
        

#### D. 数据存储与运维

- **关系型数据库:** **MySQL 8.0**
    
    - **理由:** 存储机器信息、用户对话日志、工单状态。结构化数据的不二之选。
        
- **任务队列:** **Redis (可选)**
    
    - **理由:** 如果需要异步发送邮件/短信通知维护人员，或者处理大量的机器信息上报，Redis 可以作为缓冲。
        

#### E. 运维管理端 (Admin Dashboard)

维护人员不可能通过 C/S 客户端去管理知识库，Web 页面最方便。

- **前端框架:** **Vue 3 + Element Plus**
    
    - **理由:** 开发后台管理系统最快的组合。维护人员可以通过浏览器登录，查看无法解决的问题，手动回复并点击“加入知识库”。
        

---

### 3. 核心业务流程设计 (RAG Loop)

1. **用户提问:** 客户端通过 WebSocket 发送问题。
    
2. **RAG 检索:** LangChain 在 FAISS 中检索相似文档。
    
3. **AI 回答:** LLM 结合检索结果生成回答。
    
    - _分支 A (解决):_ 用户点赞，对话结束。
        
    - _分支 B (未解决):_ 用户点击“转人工/未解决”。
        
4. **自动工单 (Escalation):**
    
    - 系统将该问题 + AI的回答 + **当前机器硬件快照** 打包存入 MySQL。
        
    - 通过 API 调用短信/邮件接口，**通知维护人员**。
        
5. **人工介入与回填 (Human-in-the-loop):**
    
    - 维护人员在 Web 端看到工单。
        
    - 维护人员填写标准解决方案。
        
    - **关键一步:** 系统自动将“问题 + 人工标准答案”向量化，**插入 FAISS 知识库**。
        
    - 下次有人问同样问题，AI 就能直接回答了。
        

### 4. 下一步建议

既然你要从零开始，我建议你按照以下顺序进行 MVP (最小可行性产品) 开发：

1. **服务端先行:** 先用 Python + LangChain + FastAPI 写一个简单的接口，把 RAG 跑通（能回答预设的几个问题）。
    
2. **客户端跟进:** 写一个最简单的 PyQt 窗口，能发消息给上面的接口。
    
3. **硬件模块:** 写一个 Python 脚本，测试能不能读取本机显卡型号和内存大小。
    

你现在想先看**服务端的 RAG 实现代码**，还是**客户端的硬件读取代码**？

## API文档

---
### 📡 接口基础约定

* **鉴权方式**： Bearer Token (JWT)

- 所有非登录接口，必须在 Header 中携带: `Authorization: Bearer <your_access_token>`

- **Base URL**: `http://<服务器IP>:8000/api/v1`
    
- **数据格式**: JSON
    
- **通用响应结构**:
    
    JSON
    
    ```
    {
      "code": 200,      // 200成功，其他为错误码
      "msg": "success", // 提示信息
      "data": {}        // 具体业务数据
    }
    ```
    

---

### 0. 🔐 身份认证模块 (Auth)

本模块负责发放访问令牌（Token）。FastAPI 原生支持 OAuth2 密码模式，非常适合此场景。

#### 0.1 管理员登录 (Web端/运维端)

- **URL**: `/auth/admin/login`
    
- **Method**: `POST`
    
- **Content-Type**: `application/x-www-form-urlencoded` (FastAPI `OAuth2PasswordRequestForm` 标准格式) 或 `application/json`
    
- **描述**: 运维人员通过账号密码登录，获取 Token 用于管理知识库和查看工单。
    
- **Request Body**:
    
    JSON
    
    ```
    {
      "username": "admin",
      "password": "secret_password"
    }
    ```
    
- **Response**:
    
    JSON
    
    ```
    {
      "code": 200,
      "data": {
        "access_token": "eyJhbGciOiJIUzI1Ni...", // JWT 字符串
        "token_type": "bearer",
        "expires_in": 86400, // 24小时过期
        "user_info": {
            "id": 1,
            "role": "admin",
            "name": "超级管理员"
        }
      }
    }
    ```
    

#### 0.2 终端设备注册/登录 (Client端 - 自动执行)

- **URL**: `/auth/device/login`
    
- **Method**: `POST`
    
- **描述**: 网吧机器开机启动客户端时，**静默自动调用**。不需玩家输入密码，而是通过机器的唯一标识（MAC地址或硬盘序列号）来向服务器“自证身份”。
    
- **Request Body**:
    
    JSON
    
    ```
    {
      "machine_id": "00-1A-2B-3C-4D-5E", // 唯一标识 (MAC地址建议去冒号作为ID)
      "hostname": "ZONE-A-001",          // 机器名，方便网管识别位置
      "secret_key": "netbar_v1_secret",  // (可选) 客户端硬编码的一个简单密钥，防止恶意脚本随便调用
      "ip_address": "192.168.1.101"      // 当前内网IP
    }
    ```
    
- **Response**:
    
    JSON
    
    ```
    {
      "code": 200,
      "msg": "设备认证成功",
      "data": {
        "access_token": "eyJhbGciOiJIUzI1Ni...", // 设备专用 Token
        "config": {
            "heartbeat_interval": 60, // 告诉客户端：每60秒发一次心跳/硬件监控
            "allow_chat": true        // 远程控制开关：是否允许使用AI助手
        }
      }
    }
    ```

### 1. 🤖 AI 对话模块 (核心 RAG)

考虑到大模型生成速度慢，建议使用 **WebSocket** 实现流式对话（打字机效果），但为了简化，这里也提供了 **HTTP** 版本。

#### 1.1 发起对话 (HTTP版)

- **URL**: `/chat/ask`
    
- **Method**: `POST`
    
- **描述**: 客户端发送问题，获取 AI 回答（等待时间较长）。
    
- **Request Body**:
    
    JSON
    
    ```
    {
      "client_id": "PC-001",    // 机器编号
      "session_id": "uuid-...", // 会话ID (用于保持多轮对话上下文)
      "question": "我的电脑玩LOL掉帧怎么办？"
    }
    ```
    
- **Response**:
    
    JSON
    
    ```
    {
      "code": 200,
      "data": {
        "answer": "玩LOL掉帧可能是显卡驱动问题...",
        "source": ["知识库文档A.txt", "维护手册_V2.pdf"] // 引用来源，增强可信度
      }
    }
    ```
    

#### 1.2 建立流式对话 (WebSocket版 - 推荐)

- **URL**: `ws://<服务器IP>:8000/ws/chat/{client_id}`
    
- **描述**: 建立长连接，实现打字机效果。
    
- **流程**:
    
    1. 客户端发送 JSON: `{"question": "..."}`
        
    2. 服务端分片返回: `{"type": "token", "content": "玩"}` -> `{"type": "token", "content": "LOL"}` ...
        
    3. 服务端发送结束: `{"type": "end"}`
        

---

### 2. 🛠️ 运维工单模块 (问题升级)

当 AI 无法解决问题时，客户端调用此接口通知维护人员。

#### 2.1 提交人工工单

- **URL**: `/ticket/create`
    
- **Method**: `POST`
    
- **描述**: 记录问题详情，并触发短信/邮件通知维护人员。
    
- **Request Body**:
    
    JSON
    
    ```
    {
      "client_id": "PC-001",
      "description": "AI没解决，屏幕一直闪烁",
      "chat_history_summary": "用户询问屏幕闪烁，AI建议重启，无效。", // 可选，由AI自动总结上下文
      "urgent_level": "high" // high/normal
    }
    ```
    
- **Response**:
    
    JSON
    
    ```
    {
      "code": 200,
      "msg": "已通知网管，请稍候",
      "data": {
        "ticket_id": 1024
      }
    }
    ```
    

---

### 3. 🖥️ 硬件监控模块 (信息收集)

客户端定期（如每10分钟）或在启动时上报硬件状态。

#### 3.1 上报硬件信息

- **URL**: `/hardware/report`
    
- **Method**: `POST`
    
- **Request Body**:
    
    JSON
    
    ```
    {
      "client_id": "PC-001",
      "os_version": "Windows 11",
      "cpu": {
        "model": "Intel i5-12400F",
        "usage_percent": 15.5
      },
      "memory": {
        "total_gb": 16,
        "used_percent": 45.0
      },
      "gpu": {
        "name": "NVIDIA GeForce RTX 3060",
        "temperature": 65,  // 显卡温度，网吧重点关注
        "driver_version": "536.23"
      },
      "network": {
        "ip": "192.168.1.101",
        "mac": "00:1A:2B:3C:4D:5E"
      }
    }
    ```
    

---

### 4. 📚 知识库管理模块 (运维端 Web 使用)

#### 4.1 补充知识库 (反馈闭环)

- **URL**: `/knowledge/add`
    
- **Method**: `POST`
    
- **描述**: 维护人员解决问题后，将“问题+标准答案”录入系统。**后端会自动调用 Embedding 模型将其向量化存入 FAISS。**
    
- **Request Body**:
    
    JSON
    
    ```
    {
      "question": "玩吃鸡提示显存不足",
      "answer": "请在设置中将虚拟内存调整为自动管理，并检查是否开启了多余的后台程序。",
      "category": "游戏故障",
      "source_ticket_id": 1024 // 关联之前的工单ID
    }
    ```
    

#### 4.2 查看待处理工单列表

- **URL**: `/ticket/list`
    
- **Method**: `GET`
    
- **Parameters**: `?status=pending` (只看未解决的)
    
- **Response**:
    
    JSON
    
    ```
    {
      "code": 200,
      "data": [
        {
          "ticket_id": 1024,
          "client_id": "PC-001",
          "description": "屏幕闪烁",
          "create_time": "2023-10-27 14:00:00"
        }
      ]
    }
    ```
    
---
## 表结构

没问题，SQL 代码虽然精确但不够直观。为了让你一眼看清表与表之间的关系，我为你生成了 **Mermaid 实体关系图 (ER Diagram)**。

你可以直接复制这段代码到支持 Mermaid 的编辑器（如 Notion, Obsidian, 或 VS Code 插件）中查看，或者直接看下面的渲染结果。

### 📊 数据库实体关系图 (ER Diagram)




这张图展示了三个核心模块（**系统、业务、日志**）是如何通过 ID 关联起来的。

代码段

```
erDiagram
    %% ---------------------------------------------------
    %% 1. 系统模块 (System Module)
    %% ---------------------------------------------------
    sys_user {
        int id PK "主键"
        string username "用户名"
        string role "角色 (admin/staff)"
        datetime last_login "最后登录"
    }

    sys_device {
        int id PK "主键"
        string machine_id "MAC地址 (唯一)"
        string hostname "机号 (ZONE-A-01)"
        json specs_summary "硬件配置 (CPU/GPU)"
        tinyint status "1在线 / 0离线"
    }

    %% ---------------------------------------------------
    %% 2. 业务模块 (Business Module)
    %% ---------------------------------------------------
    biz_ticket {
        int id PK "主键"
        int device_id FK "关联设备"
        string description "故障描述"
        enum status "pending/resolved"
        int handler_id FK "处理人(网管)"
        string admin_reply "解决方案"
    }

    ai_knowledge {
        int id PK "主键"
        string question "标准问题"
        string answer "标准答案"
        string category "分类"
        int source_ticket_id FK "来源工单"
        tinyint is_embedded "0未向量化 / 1已向量化"
    }

    %% ---------------------------------------------------
    %% 3. 日志模块 (Log Module)
    %% ---------------------------------------------------
    log_hardware {
        bigint id PK "主键"
        int device_id FK "关联设备"
        float gpu_temp "显卡温度"
        float cpu_usage "CPU使用率"
        datetime created_at "上报时间"
    }

    log_chat {
        bigint id PK "主键"
        string session_id "会话ID"
        int device_id FK "关联设备"
        text user_query "用户提问"
        text ai_response "AI回答"
    }

    %% ---------------------------------------------------
    %% 关系定义 (Relationships)
    %% ---------------------------------------------------
    
    %% 一个设备可以产生多条硬件日志 (1:N)
    sys_device ||--o{ log_hardware : "定时上报(Monitor)"
    
    %% 一个设备可以产生多条对话记录 (1:N)
    sys_device ||--o{ log_chat : "发起对话(Chat)"
    
    %% 一个设备可以提交多个工单 (1:N)
    sys_device ||--o{ biz_ticket : "报错(Report)"
    
    %% 一个管理员可以处理多个工单 (1:N)
    sys_user ||--o{ biz_ticket : "处理(Handle)"
    
    %% 一个工单可以转化为一条知识库条目 (0:1)
    biz_ticket |o--o| ai_knowledge : "沉淀为(Convert)"
```

---

### 🗺️ 图表解读指南

为了让你更清楚地理解数据是如何流转的，这里补充一个**业务数据流向图**，解释了为什么表要这样设计：

#### 核心业务闭环图 (The Data Loop)

代码段

```
graph TD
    subgraph 客户端[Client / Device]
        D(sys_device) -->|1. 硬件数据| LH(log_hardware)
        D -->|2. 提问| C(log_chat)
        D -->|3. AI解决不了 -> 提交工单| T(biz_ticket)
    end

    subgraph 服务端/运维[Server / Admin]
        U(sys_user) -->|4. 处理工单| T
        T -->|5. 填写解决方案| T_Update[更新 biz_ticket]
        T_Update -->|6. 点击'入库'| K(ai_knowledge)
        K -->|7. 后台自动向量化| V((FAISS向量库))
    end

    subgraph 智能回答[AI RAG]
        V -.->|8. 检索相似问题| C
    end
    
    style D fill:#e1f5fe,stroke:#01579b
    style T fill:#fff9c4,stroke:#fbc02d
    style K fill:#e8f5e9,stroke:#2e7d32
    style V fill:#f3e5f5,stroke:#7b1fa2
```

### 🔑 关键设计点回顾

1. **`sys_device` (核心节点)**: 它是所有数据的源头。无论是日志、对话还是工单，都需要通过 `device_id` 关联回这台设备，这样你才能统计“哪台机器故障率最高”。
    
2. **`biz_ticket` -> `ai_knowledge`**: 这是一个**漏斗关系**。
    
    - 不是所有工单都会变成知识库。
        
    - 只有那些**有代表性、高频发生**的问题，才会被管理员转化到 `ai_knowledge` 表中。
        
3. **`is_embedded` 字段**: 在 `ai_knowledge` 表中，这个字段至关重要。它充当了**MySQL 和 FAISS 之间的同步信号灯**。
    
    - `0`: 刚录入 MySQL，AI 还不知道这个知识。
        
    - `1`: Python 脚本已经把它读取并存入 FAISS 了，AI 可以检索到了。