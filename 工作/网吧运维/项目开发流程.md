## 需求分析

**核心**：
搭建大模型和RAG，结合本地知识库回答客户的问题
**其他**：
1. 问题无法解决通知维护人员
2. 记录每次问题解决的流程补充知识库
3. 收集网吧机器的信息

## 技术选型

### 1. 系统架构图 (Conceptual)

- **Client (网吧终端):** 负责用户交互、硬件信息采集、问题上报。
    
- **Server (中心服务器):** 负责 AI 推理、RAG 检索、业务逻辑、通知分发。
    
- **Admin (运维管理端):** 这是一个 Web 端，供维护人员查看报警、管理知识库。
    

---

### 2. 详细技术选型清单

#### A. 客户端 (Client) - 网吧机器终端

需要运行在 Windows 上，且由于需要“收集机器信息”，原生应用比 Web 网页更合适。

- **GUI 框架:** **PyQt6 (或 PySide6)**
    
    - **理由:** 你需要开发 C/S 架构，PyQt 对 Windows 原生控件支持好，且 Python 有丰富的库（如 `psutil`, `WMI`）可以直接读取网卡、显卡、内存等硬件信息，这比用 Electron 调用底层 API 要简单得多。
        
- **打包工具:** **Nuitka**
    
    - **理由:** 网吧环境复杂，源码保护很重要。Nuitka 将 Python 编译为 C++ 代码再生成 exe，启动速度快，且难以被反编译，非常适合商业部署。
        
- **硬件监控:** **psutil + GPUtil**
    
    - **理由:** 用于获取 CPU、内存、磁盘、以及网吧最看重的**显卡(GPU)**状态。
        

#### B. 后端服务 (Server) - AI与业务中台

- **Web 框架:** **FastAPI**
    
    - **理由:** 高性能，原生支持异步（Async），非常适合处理 AI 模型的流式输出（Streaming Response），让用户感觉响应很快。
        
- **通信协议:** **HTTP (RESTful) + WebSocket**
    
    - **理由:** 常规请求用 HTTP；AI 对话使用 WebSocket，可以实现“打字机效果”，提升用户体验。
        

#### C. AI 与 RAG 核心 (The Brain)

这是项目的核心部分。

- **大模型编排:** **LangChain**
    
    - **理由:** 事实上的行业标准。你可以用它轻松构建“检索-增强-生成”的链路，管理 Prompt 和上下文历史。
        
- **向量数据库:** **FAISS (本地文件版) 或 ChromaDB**
    
    - **理由:** 考虑到知识库主要针对网吧业务，数据量不会达到亿级。FAISS 极其轻量，可以直接嵌入在服务端代码中，无需单独维护一个庞大的向量数据库服务。
        
- **Embedding 模型:** **BGE-M3 或 OpenAI text-embedding-3-small**
    
    - **理由:** 中文语义理解能力强，检索准确率高。
        
- **LLM 模型:**
    
    - _方案一 (云端):_ **DeepSeek V3 / Qwen-Max** (API 调用，成本低，速度快)。
        
    - _方案二 (私有化):_ **Ollama + Qwen2.5-14B** (如果网吧服务器显卡够好，可以本地部署，数据更安全)。
        

#### D. 数据存储与运维

- **关系型数据库:** **MySQL 8.0**
    
    - **理由:** 存储机器信息、用户对话日志、工单状态。结构化数据的不二之选。
        
- **任务队列:** **Redis (可选)**
    
    - **理由:** 如果需要异步发送邮件/短信通知维护人员，或者处理大量的机器信息上报，Redis 可以作为缓冲。
        

#### E. 运维管理端 (Admin Dashboard)

维护人员不可能通过 C/S 客户端去管理知识库，Web 页面最方便。

- **前端框架:** **Vue 3 + Element Plus**
    
    - **理由:** 开发后台管理系统最快的组合。维护人员可以通过浏览器登录，查看无法解决的问题，手动回复并点击“加入知识库”。
        

---

### 3. 核心业务流程设计 (RAG Loop)

1. **用户提问:** 客户端通过 WebSocket 发送问题。
    
2. **RAG 检索:** LangChain 在 FAISS 中检索相似文档。
    
3. **AI 回答:** LLM 结合检索结果生成回答。
    
    - _分支 A (解决):_ 用户点赞，对话结束。
        
    - _分支 B (未解决):_ 用户点击“转人工/未解决”。
        
4. **自动工单 (Escalation):**
    
    - 系统将该问题 + AI的回答 + **当前机器硬件快照** 打包存入 MySQL。
        
    - 通过 API 调用短信/邮件接口，**通知维护人员**。
        
5. **人工介入与回填 (Human-in-the-loop):**
    
    - 维护人员在 Web 端看到工单。
        
    - 维护人员填写标准解决方案。
        
    - **关键一步:** 系统自动将“问题 + 人工标准答案”向量化，**插入 FAISS 知识库**。
        
    - 下次有人问同样问题，AI 就能直接回答了。
        

### 4. 下一步建议

既然你要从零开始，我建议你按照以下顺序进行 MVP (最小可行性产品) 开发：

1. **服务端先行:** 先用 Python + LangChain + FastAPI 写一个简单的接口，把 RAG 跑通（能回答预设的几个问题）。
    
2. **客户端跟进:** 写一个最简单的 PyQt 窗口，能发消息给上面的接口。
    
3. **硬件模块:** 写一个 Python 脚本，测试能不能读取本机显卡型号和内存大小。
    

你现在想先看**服务端的 RAG 实现代码**，还是**客户端的硬件读取代码**？

## API文档

---
### 📡 接口基础约定

* **鉴权方式**： Bearer Token (JWT)

- 所有非登录接口，必须在 Header 中携带: `Authorization: Bearer <your_access_token>`

- **Base URL**: `http://<服务器IP>:8000/api/v1`
    
- **数据格式**: JSON
    
- **通用响应结构**:
    
    JSON
    
    ```
    {
      "code": 200,      // 200成功，其他为错误码
      "msg": "success", // 提示信息
      "data": {}        // 具体业务数据
    }
    ```
    

---



### 1. 🤖 AI 对话模块 (核心 RAG)

考虑到大模型生成速度慢，建议使用 **WebSocket** 实现流式对话（打字机效果），但为了简化，这里也提供了 **HTTP** 版本。

#### 1.1 发起对话 (HTTP版)

- **URL**: `/chat/ask`
    
- **Method**: `POST`
    
- **描述**: 客户端发送问题，获取 AI 回答（等待时间较长）。
    
- **Request Body**:
    
    JSON
    
    ```
    {
      "client_id": "PC-001",    // 机器编号
      "session_id": "uuid-...", // 会话ID (用于保持多轮对话上下文)
      "question": "我的电脑玩LOL掉帧怎么办？"
    }
    ```
    
- **Response**:
    
    JSON
    
    ```
    {
      "code": 200,
      "data": {
        "answer": "玩LOL掉帧可能是显卡驱动问题...",
        "source": ["知识库文档A.txt", "维护手册_V2.pdf"] // 引用来源，增强可信度
      }
    }
    ```
    

#### 1.2 建立流式对话 (WebSocket版 - 推荐)

- **URL**: `ws://<服务器IP>:8000/ws/chat/{client_id}`
    
- **描述**: 建立长连接，实现打字机效果。
    
- **流程**:
    
    1. 客户端发送 JSON: `{"question": "..."}`
        
    2. 服务端分片返回: `{"type": "token", "content": "玩"}` -> `{"type": "token", "content": "LOL"}` ...
        
    3. 服务端发送结束: `{"type": "end"}`
        

---

### 2. 🛠️ 运维工单模块 (问题升级)

当 AI 无法解决问题时，客户端调用此接口通知维护人员。

#### 2.1 提交人工工单

- **URL**: `/ticket/create`
    
- **Method**: `POST`
    
- **描述**: 记录问题详情，并触发短信/邮件通知维护人员。
    
- **Request Body**:
    
    JSON
    
    ```
    {
      "client_id": "PC-001",
      "description": "AI没解决，屏幕一直闪烁",
      "chat_history_summary": "用户询问屏幕闪烁，AI建议重启，无效。", // 可选，由AI自动总结上下文
      "urgent_level": "high" // high/normal
    }
    ```
    
- **Response**:
    
    JSON
    
    ```
    {
      "code": 200,
      "msg": "已通知网管，请稍候",
      "data": {
        "ticket_id": 1024
      }
    }
    ```
    

---

### 3. 🖥️ 硬件监控模块 (信息收集)

客户端定期（如每10分钟）或在启动时上报硬件状态。

#### 3.1 上报硬件信息

- **URL**: `/hardware/report`
    
- **Method**: `POST`
    
- **Request Body**:
    
    JSON
    
    ```
    {
      "client_id": "PC-001",
      "os_version": "Windows 11",
      "cpu": {
        "model": "Intel i5-12400F",
        "usage_percent": 15.5
      },
      "memory": {
        "total_gb": 16,
        "used_percent": 45.0
      },
      "gpu": {
        "name": "NVIDIA GeForce RTX 3060",
        "temperature": 65,  // 显卡温度，网吧重点关注
        "driver_version": "536.23"
      },
      "network": {
        "ip": "192.168.1.101",
        "mac": "00:1A:2B:3C:4D:5E"
      }
    }
    ```
    

---

### 4. 📚 知识库管理模块 (运维端 Web 使用)

#### 4.1 补充知识库 (反馈闭环)

- **URL**: `/knowledge/add`
    
- **Method**: `POST`
    
- **描述**: 维护人员解决问题后，将“问题+标准答案”录入系统。**后端会自动调用 Embedding 模型将其向量化存入 FAISS。**
    
- **Request Body**:
    
    JSON
    
    ```
    {
      "question": "玩吃鸡提示显存不足",
      "answer": "请在设置中将虚拟内存调整为自动管理，并检查是否开启了多余的后台程序。",
      "category": "游戏故障",
      "source_ticket_id": 1024 // 关联之前的工单ID
    }
    ```
    

#### 4.2 查看待处理工单列表

- **URL**: `/ticket/list`
    
- **Method**: `GET`
    
- **Parameters**: `?status=pending` (只看未解决的)
    
- **Response**:
    
    JSON
    
    ```
    {
      "code": 200,
      "data": [
        {
          "ticket_id": 1024,
          "client_id": "PC-001",
          "description": "屏幕闪烁",
          "create_time": "2023-10-27 14:00:00"
        }
      ]
    }
    ```
    

---
