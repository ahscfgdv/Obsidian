## 需求分析

**核心**：
搭建大模型和RAG，结合本地知识库回答客户的问题
**其他**：
1. 问题无法解决通知维护人员
2. 记录每次问题解决的流程补充知识库
3. 收集网吧机器的信息

## 技术选型

### 1. 系统架构图 (Conceptual)

- **ClientA (监控哨兵):** 负责用户交互、硬件信息采集、问题上报。 
	
- **ClientB（管理中台）**
    
- **Server (中心服务器):** 负责 AI 推理、RAG 检索、业务逻辑、通知分发。
    
- **Admin (运维管理端):** 这是一个 Web 端，供维护人员查看报警、管理知识库。
    

---

### 2. 详细技术选型清单

#### A. 客户端 (Client) 

##### 🖥️ 客户端 A：监控哨兵 (Monitor Agent)

- **部署位置**：网吧所有客户机。
    
- **形态**：**无界面（Headless）** 或 **托盘程序**。Windows 服务形式运行。
    
- **核心职责**：
    
    1. **静默采集**：开机自动启动，每 5-10 分钟上报一次 CPU、显卡型号、温度、驱动版本。
        
    2. **心跳保活**：告诉服务器“我还活着”。
        
    3. **被动指令执行**：接收来自前台的简单指令（如：截取当前屏幕发给前台、重启进程）。
        
- **技术关键**：
    
    - 使用 `Nuitka` 打包成无控制台的后台进程。
        
    - 资源占用必须极低（CPU < 1%），否则玩游戏卡顿会被投诉。
        

##### 💻 客户端 B：管理中台 (Admin Station)

- **部署位置**：网吧吧台/网管电脑。
    
- **形态**：**全功能桌面应用 (PyQt6)**。
    
- **核心职责**：
    
    1. **全景监控大盘**：一个列表展示所有机器状态（绿色=正常，红色=显卡掉驱动/高温）。
        
    2. **AI 智能助手**：网管遇到不懂的问题，在这里问 AI。
        
    3. **工单闭环 (关键逻辑)**：
        
        - **场景**：某机器报错 -> 监控端自动上报 -> 前台端弹窗报警。
            
        - **处理**：网管点击报警 -> AI 自动分析硬件日志给出建议。
            
        - **归档**：网管解决后，点击“**解决并存入知识库**”，系统将“故障现象+硬件环境+解决方案”自动向量化存入系统。

#### B. 后端服务 (Server) - AI与业务中台

- **Web 框架:** **FastAPI**
    
    - **理由:** 高性能，原生支持异步（Async），非常适合处理 AI 模型的流式输出（Streaming Response），让用户感觉响应很快。
        
- **通信协议:** **HTTP (RESTful) + WebSocket**
    
    - **理由:** 常规请求用 HTTP；AI 对话使用 WebSocket，可以实现“打字机效果”，提升用户体验。
        

#### C. AI 与 RAG 核心 (The Brain)

这是项目的核心部分。

- **大模型编排:** **LangChain**
    
    - **理由:** 事实上的行业标准。你可以用它轻松构建“检索-增强-生成”的链路，管理 Prompt 和上下文历史。
        
- **向量数据库:** **FAISS (本地文件版) 或 ChromaDB**
    
    - **理由:** 考虑到知识库主要针对网吧业务，数据量不会达到亿级。FAISS 极其轻量，可以直接嵌入在服务端代码中，无需单独维护一个庞大的向量数据库服务。
        
- **Embedding 模型:** **BGE-M3 或 OpenAI text-embedding-3-small**
    
    - **理由:** 中文语义理解能力强，检索准确率高。
        
- **LLM 模型:**
    
    - _方案一 (云端):_ **DeepSeek V3 / Qwen-Max** (API 调用，成本低，速度快)。
        
    - _方案二 (私有化):_ **Ollama + Qwen2.5-14B** (如果网吧服务器显卡够好，可以本地部署，数据更安全)。
        

#### D. 数据存储与运维

- **关系型数据库:** **MySQL 8.0**
    
    - **理由:** 存储机器信息、用户对话日志、工单状态。结构化数据的不二之选。
        
- **任务队列:** **Redis (可选)**
    
    - **理由:** 如果需要异步发送邮件/短信通知维护人员，或者处理大量的机器信息上报，Redis 可以作为缓冲。
        

#### E. 运维管理端 (Admin Dashboard)

维护人员不可能通过 C/S 客户端去管理知识库，Web 页面最方便。

- **前端框架:** **Vue 3 + Element Plus**
    
    - **理由:** 开发后台管理系统最快的组合。维护人员可以通过浏览器登录，查看无法解决的问题，手动回复并点击“加入知识库”。
        

---

### 3. 核心业务流程设计 (RAG Loop)

1. **用户提问:** 客户端通过 WebSocket 发送问题。
    
2. **RAG 检索:** LangChain 在 FAISS 中检索相似文档。
    
3. **AI 回答:** LLM 结合检索结果生成回答。
    
    - _分支 A (解决):_ 用户点赞，对话结束。
        
    - _分支 B (未解决):_ 用户点击“转人工/未解决”。
        
4. **自动工单 (Escalation):**
    
    - 系统将该问题 + AI的回答 + **当前机器硬件快照** 打包存入 MySQL。
        
    - 通过 API 调用短信/邮件接口，**通知维护人员**。
        
5. **人工介入与回填 (Human-in-the-loop):**
    
    - 维护人员在 Web 端看到工单。
        
    - 维护人员填写标准解决方案。
        
    - **关键一步:** 系统自动将“问题 + 人工标准答案”向量化，**插入 FAISS 知识库**。
        
    - 下次有人问同样问题，AI 就能直接回答了。
        

### 4. 下一步建议

既然你要从零开始，我建议你按照以下顺序进行 MVP (最小可行性产品) 开发：

1. **服务端先行:** 先用 Python + LangChain + FastAPI 写一个简单的接口，把 RAG 跑通（能回答预设的几个问题）。
    
2. **客户端跟进:** 写一个最简单的 PyQt 窗口，能发消息给上面的接口。
    
3. **硬件模块:** 写一个 Python 脚本，测试能不能读取本机显卡型号和内存大小。
    

你现在想先看**服务端的 RAG 实现代码**，还是**客户端的硬件读取代码**？

## API文档

---
### 📡 接口基础约定

* **鉴权方式**： Bearer Token (JWT)

- 所有非登录接口，必须在 Header 中携带: `Authorization: Bearer <your_access_token>`

- **Base URL**: `http://<服务器IP>:8000/api/v1`
    
- **数据格式**: JSON
    
- **通用响应结构**:
    
    JSON
    
    ```
    {
      "code": 200,      // 200成功，其他为错误码
      "msg": "success", // 提示信息
      "data": {}        // 具体业务数据
    }
    ```
    

---

### 0. 🔐 身份认证模块 (Auth)

本模块负责发放访问令牌（Token）。FastAPI 原生支持 OAuth2 密码模式，非常适合此场景。

#### 0.1 管理员登录 (Web端/运维端)

- **URL**: `/auth/admin/login`
    
- **Method**: `POST`
    
- **Content-Type**: `application/x-www-form-urlencoded` (FastAPI `OAuth2PasswordRequestForm` 标准格式) 或 `application/json`
    
- **描述**: 运维人员通过账号密码登录，获取 Token 用于管理知识库和查看工单。
    
- **Request Body**:
    
    JSON
    
    ```
    {
      "username": "admin",
      "password": "secret_password"
    }
    ```
    
- **Response**:
    
    JSON
    
    ```
    {
      "code": 200,
      "data": {
        "access_token": "eyJhbGciOiJIUzI1Ni...", // JWT 字符串
        "token_type": "bearer",
        "expires_in": 86400, // 24小时过期
        "user_info": {
            "id": 1,
            "role": "admin",
            "name": "超级管理员"
        }
      }
    }
    ```
    

#### 0.2 终端设备注册/登录 (Client端 - 自动执行)

- **URL**: `/auth/device/login`
    
- **Method**: `POST`
    
- **描述**: 网吧机器开机启动客户端时，**静默自动调用**。不需玩家输入密码，而是通过机器的唯一标识（MAC地址或硬盘序列号）来向服务器“自证身份”。
    
- **Request Body**:
    
    JSON
    
    ```
    {
      "machine_id": "00-1A-2B-3C-4D-5E", // 唯一标识 (MAC地址建议去冒号作为ID)
      "hostname": "ZONE-A-001",          // 机器名，方便网管识别位置
      "secret_key": "netbar_v1_secret",  // (可选) 客户端硬编码的一个简单密钥，防止恶意脚本随便调用
      "ip_address": "192.168.1.101"      // 当前内网IP
    }
    ```
    
- **Response**:
    
    JSON
    
    ```
    {
      "code": 200,
      "msg": "设备认证成功",
      "data": {
        "access_token": "eyJhbGciOiJIUzI1Ni...", // 设备专用 Token
        "config": {
            "heartbeat_interval": 60, // 告诉客户端：每60秒发一次心跳/硬件监控
            "allow_chat": true        // 远程控制开关：是否允许使用AI助手
        }
      }
    }
    ```

### 1. 🤖 AI 对话模块 (核心 RAG)

考虑到大模型生成速度慢，建议使用 **WebSocket** 实现流式对话（打字机效果），但为了简化，这里也提供了 **HTTP** 版本。

#### 1.1 发起对话 (HTTP版)

- **URL**: `/chat/ask`
    
- **Method**: `POST`
    
- **描述**: 客户端发送问题，获取 AI 回答（等待时间较长）。
    
- **Request Body**:
    
    JSON
    
    ```
    {
      "client_id": "PC-001",    // 机器编号
      "session_id": "uuid-...", // 会话ID (用于保持多轮对话上下文)
      "question": "我的电脑玩LOL掉帧怎么办？"
    }
    ```
    
- **Response**:
    
    JSON
    
    ```
    {
      "code": 200,
      "data": {
        "answer": "玩LOL掉帧可能是显卡驱动问题...",
        "source": ["知识库文档A.txt", "维护手册_V2.pdf"] // 引用来源，增强可信度
      }
    }
    ```
    

#### 1.2 建立流式对话 (WebSocket版 - 推荐)

- **URL**: `ws://<服务器IP>:8000/ws/chat/{client_id}`
    
- **描述**: 建立长连接，实现打字机效果。
    
- **流程**:
    
    1. 客户端发送 JSON: `{"question": "..."}`
        
    2. 服务端分片返回: `{"type": "token", "content": "玩"}` -> `{"type": "token", "content": "LOL"}` ...
        
    3. 服务端发送结束: `{"type": "end"}`
        

---

### 2. 🛠️ 运维工单模块 (问题升级)

当 AI 无法解决问题时，客户端调用此接口通知维护人员。

#### 2.1 提交人工工单

- **URL**: `/ticket/create`
    
- **Method**: `POST`
    
- **描述**: 记录问题详情，并触发短信/邮件通知维护人员。
    
- **Request Body**:
    
    JSON
    
    ```
    {
      "client_id": "PC-001",
      "description": "AI没解决，屏幕一直闪烁",
      "chat_history_summary": "用户询问屏幕闪烁，AI建议重启，无效。", // 可选，由AI自动总结上下文
      "urgent_level": "high" // high/normal
    }
    ```
    
- **Response**:
    
    JSON
    
    ```
    {
      "code": 200,
      "msg": "已通知网管，请稍候",
      "data": {
        "ticket_id": 1024
      }
    }
    ```
    

---

### 3. 🖥️ 硬件监控模块 (信息收集)

客户端定期（如每10分钟）或在启动时上报硬件状态。

#### 3.1 上报硬件信息

- **URL**: `/hardware/report`
    
- **Method**: `POST`
    
- **Request Body**:
    
    JSON
    
    ```
    {
      "client_id": "PC-001",
      "os_version": "Windows 11",
      "cpu": {
        "model": "Intel i5-12400F",
        "usage_percent": 15.5
      },
      "memory": {
        "total_gb": 16,
        "used_percent": 45.0
      },
      "gpu": {
        "name": "NVIDIA GeForce RTX 3060",
        "temperature": 65,  // 显卡温度，网吧重点关注
        "driver_version": "536.23"
      },
      "network": {
        "ip": "192.168.1.101",
        "mac": "00:1A:2B:3C:4D:5E"
      }
    }
    ```
    

---

### 4. 📚 知识库管理模块 (运维端 Web 使用)

#### 4.1 补充知识库 (反馈闭环)

- **URL**: `/knowledge/add`
    
- **Method**: `POST`
    
- **描述**: 维护人员解决问题后，将“问题+标准答案”录入系统。**后端会自动调用 Embedding 模型将其向量化存入 FAISS。**
    
- **Request Body**:
    
    JSON
    
    ```
    {
      "question": "玩吃鸡提示显存不足",
      "answer": "请在设置中将虚拟内存调整为自动管理，并检查是否开启了多余的后台程序。",
      "category": "游戏故障",
      "source_ticket_id": 1024 // 关联之前的工单ID
    }
    ```
    

#### 4.2 查看待处理工单列表

- **URL**: `/ticket/list`
    
- **Method**: `GET`
    
- **Parameters**: `?status=pending` (只看未解决的)
    
- **Response**:
    
    JSON
    
    ```
    {
      "code": 200,
      "data": [
        {
          "ticket_id": 1024,
          "client_id": "PC-001",
          "description": "屏幕闪烁",
          "create_time": "2023-10-27 14:00:00"
        }
      ]
    }
    ```
    
---
## 表结构

基于你的项目需求（网吧机器维护 + RAG + 硬件监控），我为你设计了一套规范的 MySQL 数据库表结构。

为了方便维护和扩展，我将表分为三类：

1. **基础系统表 (`sys_`)**：管理用户（管理员）和设备（客户端）。
    
2. **核心业务表 (`biz_`)**：管理工单和知识库。
    
3. **日志流水表 (`log_`)**：记录硬件监控数据和对话历史（数据量大）。
    

### 📊 实体关系图 (ER Diagram)

为了让你更直观地理解各表之间的关联，这里有一个简化的逻辑视图：

代码段

```
erDiagram
    sys_device ||--o{ log_hardware : "上传监控"
    sys_device ||--o{ log_chat : "产生对话"
    sys_device ||--o{ biz_ticket : "提交工单"
    sys_user ||--o{ biz_ticket : "处理工单"
    biz_ticket ||--o{ ai_knowledge : "转化沉淀"

    sys_device {
        int id PK
        string machine_id "MAC/唯一标识"
        string status "online/offline"
    }
    sys_user {
        int id PK
        string username
        string role "admin/staff"
    }
    biz_ticket {
        int id PK
        string status "pending/resolved"
        string admin_reply
    }
    ai_knowledge {
        int id PK
        string question
        string answer
        string vector_id "对应FAISS索引"
    }
```

---

### 📝 详细 SQL 建表语句

你可以直接将以下 SQL 复制到 MySQL 客户端执行。

#### 1. 基础系统模块 (Auth & Devices)

SQL

```
-- 管理员表 (Web端登录用)
CREATE TABLE `sys_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(50) NOT NULL COMMENT '用户名',
  `password_hash` varchar(255) NOT NULL COMMENT '加密后的密码',
  `role` varchar(20) DEFAULT 'staff' COMMENT '角色: admin/staff',
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  `last_login` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_username` (`username`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='运维人员表';

-- 终端设备表 (Client端自动登录用)
CREATE TABLE `sys_device` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `machine_id` varchar(64) NOT NULL COMMENT '机器唯一标识(MAC或UUID)',
  `hostname` varchar(64) DEFAULT NULL COMMENT '主机名(如 ZONE-A-01)',
  `ip_address` varchar(20) DEFAULT NULL COMMENT '最后一次上报的内网IP',
  `specs_summary` json DEFAULT NULL COMMENT '配置摘要(CPU/显卡型号, JSON存储)',
  `status` tinyint(1) DEFAULT 1 COMMENT '状态: 1在线, 0离线, 2维护中',
  `last_heartbeat` datetime DEFAULT NULL COMMENT '最后心跳时间',
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_machine_id` (`machine_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='网吧终端设备表';
```

#### 2. 核心业务模块 (Ticket & Knowledge)

SQL

```
-- 运维工单表 (问题升级)
CREATE TABLE `biz_ticket` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `device_id` int(11) NOT NULL COMMENT '关联sys_device.id',
  `description` text NOT NULL COMMENT '问题描述',
  `chat_summary` varchar(500) DEFAULT NULL COMMENT 'AI生成的对话摘要',
  `status` enum('pending','processing','resolved') DEFAULT 'pending' COMMENT '状态',
  `admin_reply` text COMMENT '运维人员的解决方案',
  `handler_id` int(11) DEFAULT NULL COMMENT '处理人ID(sys_user.id)',
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  `updated_at` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_device_id` (`device_id`),
  KEY `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='故障工单表';

-- 知识库源数据表 (RAG Source)
CREATE TABLE `ai_knowledge` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `question` varchar(255) NOT NULL COMMENT '标准问题',
  `answer` text NOT NULL COMMENT '标准回答(Markdown格式)',
  `category` varchar(50) DEFAULT '通用' COMMENT '分类: 游戏/硬件/网络',
  `source_ticket_id` int(11) DEFAULT NULL COMMENT '来源工单ID(用于追溯)',
  `is_embedded` tinyint(1) DEFAULT 0 COMMENT '是否已同步到向量库(FAISS)',
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_question` (`question`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='RAG知识库源数据';
```

#### 3. 日志流水模块 (Logs)

SQL

```
-- 硬件监控流水 (建议定期清理)
CREATE TABLE `log_hardware` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `device_id` int(11) NOT NULL,
  `cpu_usage` float DEFAULT NULL COMMENT 'CPU占用率%',
  `ram_usage` float DEFAULT NULL COMMENT '内存占用率%',
  `gpu_temp` int(11) DEFAULT NULL COMMENT '显卡温度℃',
  `gpu_usage` float DEFAULT NULL COMMENT '显卡占用率%',
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_device_time` (`device_id`, `created_at`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='硬件监控日志';

-- AI对话历史 (用于审计和调优)
CREATE TABLE `log_chat` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `session_id` varchar(64) NOT NULL COMMENT '会话ID',
  `device_id` int(11) DEFAULT NULL,
  `user_query` text NOT NULL COMMENT '用户提问',
  `ai_response` text NOT NULL COMMENT 'AI回答',
  `is_helpful` tinyint(1) DEFAULT NULL COMMENT '用户反馈: 1有用, 0没用',
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_session` (`session_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='对话日志';
```

### 💡 设计要点说明

1. **JSON 类型的应用**:
    
    - 在 `sys_device` 表中，我设计了 `specs_summary` 字段为 JSON 类型。因为硬件配置信息比较杂（CPU型号、显卡型号、驱动版本），而且不需要经常作为查询条件，用 JSON 存非常灵活，不用每次加字段。
        
    - _示例数据_: `{"gpu": "RTX 3060", "cpu": "i5-12400", "driver": "536.23"}`
        
2. **知识库与 FAISS 的同步**:
    
    - `ai_knowledge` 表存储的是**人类可读**的文本。
        
    - `is_embedded` 字段用于标记状态。你的后台程序需要写一个定时任务（或触发器），查找 `is_embedded = 0` 的记录，调用 Embedding 模型生成向量插入 FAISS，然后将该字段改为 1。
        
3. **硬件日志的优化**:
    
    - `log_hardware` 表的数据量会增长极快（假设100台机器每分钟上报1次，一天就是14.4万条数据）。
        
    - **建议**: 可以在代码逻辑中做限制，只有当数值变化超过一定阈值（比如温度突增）才记录，或者只保留最近7天的数据（写一个定时清理脚本）。
        
4. **外键约束**:
    
    - 我在 SQL 中使用了 `id` 关联，但没有强制添加 `CONSTRAINT FOREIGN KEY`。在分布式或快速迭代的开发中，通常推荐**逻辑外键**（在代码里保证关联），而不是**数据库物理外键**，这样能避免很多死锁和数据迁移的麻烦。

没问题，SQL 代码虽然精确但不够直观。为了让你一眼看清表与表之间的关系，我为你生成了 **Mermaid 实体关系图 (ER Diagram)**。

你可以直接复制这段代码到支持 Mermaid 的编辑器（如 Notion, Obsidian, 或 VS Code 插件）中查看，或者直接看下面的渲染结果。

### 📊 数据库实体关系图 (ER Diagram)




这张图展示了三个核心模块（**系统、业务、日志**）是如何通过 ID 关联起来的。

代码段

```
erDiagram
    %% ---------------------------------------------------
    %% 1. 系统模块 (System Module)
    %% ---------------------------------------------------
    sys_user {
        int id PK "主键"
        string username "用户名"
        string role "角色 (admin/staff)"
        datetime last_login "最后登录"
    }

    sys_device {
        int id PK "主键"
        string machine_id "MAC地址 (唯一)"
        string hostname "机号 (ZONE-A-01)"
        json specs_summary "硬件配置 (CPU/GPU)"
        tinyint status "1在线 / 0离线"
    }

    %% ---------------------------------------------------
    %% 2. 业务模块 (Business Module)
    %% ---------------------------------------------------
    biz_ticket {
        int id PK "主键"
        int device_id FK "关联设备"
        string description "故障描述"
        enum status "pending/resolved"
        int handler_id FK "处理人(网管)"
        string admin_reply "解决方案"
    }

    ai_knowledge {
        int id PK "主键"
        string question "标准问题"
        string answer "标准答案"
        string category "分类"
        int source_ticket_id FK "来源工单"
        tinyint is_embedded "0未向量化 / 1已向量化"
    }

    %% ---------------------------------------------------
    %% 3. 日志模块 (Log Module)
    %% ---------------------------------------------------
    log_hardware {
        bigint id PK "主键"
        int device_id FK "关联设备"
        float gpu_temp "显卡温度"
        float cpu_usage "CPU使用率"
        datetime created_at "上报时间"
    }

    log_chat {
        bigint id PK "主键"
        string session_id "会话ID"
        int device_id FK "关联设备"
        text user_query "用户提问"
        text ai_response "AI回答"
    }

    %% ---------------------------------------------------
    %% 关系定义 (Relationships)
    %% ---------------------------------------------------
    
    %% 一个设备可以产生多条硬件日志 (1:N)
    sys_device ||--o{ log_hardware : "定时上报(Monitor)"
    
    %% 一个设备可以产生多条对话记录 (1:N)
    sys_device ||--o{ log_chat : "发起对话(Chat)"
    
    %% 一个设备可以提交多个工单 (1:N)
    sys_device ||--o{ biz_ticket : "报错(Report)"
    
    %% 一个管理员可以处理多个工单 (1:N)
    sys_user ||--o{ biz_ticket : "处理(Handle)"
    
    %% 一个工单可以转化为一条知识库条目 (0:1)
    biz_ticket |o--o| ai_knowledge : "沉淀为(Convert)"
```

---

### 🗺️ 图表解读指南

为了让你更清楚地理解数据是如何流转的，这里补充一个**业务数据流向图**，解释了为什么表要这样设计：

#### 核心业务闭环图 (The Data Loop)

代码段

```
graph TD
    subgraph 客户端[Client / Device]
        D(sys_device) -->|1. 硬件数据| LH(log_hardware)
        D -->|2. 提问| C(log_chat)
        D -->|3. AI解决不了 -> 提交工单| T(biz_ticket)
    end

    subgraph 服务端/运维[Server / Admin]
        U(sys_user) -->|4. 处理工单| T
        T -->|5. 填写解决方案| T_Update[更新 biz_ticket]
        T_Update -->|6. 点击'入库'| K(ai_knowledge)
        K -->|7. 后台自动向量化| V((FAISS向量库))
    end

    subgraph 智能回答[AI RAG]
        V -.->|8. 检索相似问题| C
    end
    
    style D fill:#e1f5fe,stroke:#01579b
    style T fill:#fff9c4,stroke:#fbc02d
    style K fill:#e8f5e9,stroke:#2e7d32
    style V fill:#f3e5f5,stroke:#7b1fa2
```

### 🔑 关键设计点回顾

1. **`sys_device` (核心节点)**: 它是所有数据的源头。无论是日志、对话还是工单，都需要通过 `device_id` 关联回这台设备，这样你才能统计“哪台机器故障率最高”。
    
2. **`biz_ticket` -> `ai_knowledge`**: 这是一个**漏斗关系**。
    
    - 不是所有工单都会变成知识库。
        
    - 只有那些**有代表性、高频发生**的问题，才会被管理员转化到 `ai_knowledge` 表中。
        
3. **`is_embedded` 字段**: 在 `ai_knowledge` 表中，这个字段至关重要。它充当了**MySQL 和 FAISS 之间的同步信号灯**。
    
    - `0`: 刚录入 MySQL，AI 还不知道这个知识。
        
    - `1`: Python 脚本已经把它读取并存入 FAISS 了，AI 可以检索到了。