## 三元运算符

## yeilds

`yield` 是 Python 中最强大但也最容易让新手困惑的关键字之一。

简单来说，它的作用是**把一个函数变成一个“生成器” (Generator)**。

你可以把它理解为函数的 **“暂停并返回” (Pause & Return)** 按钮，而不是普通 `return` 的 **“结束并返回” (Stop & Return)**。

---

### 1. 核心区别：`return` vs `yield`

为了理解 `yield`，我们先看它和普通函数的区别。

#### 普通函数 (`return`) —— 一次性结清

就像你去超市买东西，必须把车里所有商品（数据）一次性放到收银台，全部扫完，才能打包带走。

```Python
def make_list():
    result = []
    for i in range(3):
        result.append(i)
    return result  # 必须等所有数据生成完，一次性返回整个列表

nums = make_list()
print(nums) 
# 输出: [0, 1, 2]
# 缺点：如果数据有 1 亿个，result 列表会瞬间撑爆你的内存。
```
#### 生成器函数 (`yield`) —— 随吃随拿

就像回转寿司，厨师（函数）做好一个寿司（数据），放在传送带上给你（yield），然后他停下来休息，直到你需要下一个。

```Python
def make_gen():
    for i in range(3):
        yield i  # 产出一个数据，然后函数“暂停”在这里，保存状态
        print(f"Resuming after {i}") # 下次调用时，从这行继续执行

gen = make_gen()
# 注意：此时函数并没有执行！它只是返回了一个生成器对象
print(gen) 
# 输出: <generator object ...>

# 第一次索要数据
print(next(gen)) 
# 输出: 0 (函数暂停了)

# 第二次索要数据
print(next(gen)) 
# 输出: Resuming after 0
# 输出: 1 (函数又暂停了)
```

---

### 2. 为什么要用 `yield`？ (核心优势：省内存)

对于做 AI/数据处理的你来说，这是 `yield` 最大的意义：**惰性求值 (Lazy Evaluation)**。

假设你要处理一个 **100GB** 的日志文件或训练集。

- **不用 `yield` (加载进列表):** 需要 100GB 内存。程序直接崩溃 (OOM)。
    
- **使用 `yield` (生成器):** 内存占用极低（可能只有几 KB）。因为它一次只读一行，处理完扔掉，再读下一行。
    

**对比代码：**

Python

```
# 危险写法：占用大量内存
def get_squares_list(n):
    return [i ** 2 for i in range(n)]

# 高效写法：内存占用几乎为 0
def get_squares_gen(n):
    for i in range(n):
        yield i ** 2

# 即使 n = 1亿，下面的代码也能瞬间跑起来，且不占内存
for num in get_squares_gen(100000000):
    # 处理 num...
    if num > 100: break
```

---

### 3. `yield` 在你项目中的应用场景

结合你之前的 `IterableDataset` 和 MinIO 问题，`yield` 是实现**流式数据加载**的核心。

#### 场景：从 MinIO 流式读取大文件训练

你不希望把整个文件下载到本地（占磁盘），也不希望把整个文件读入 RAM（占内存）。

```Python
import boto3

def stream_lines_from_minio(bucket, key):
    s3 = boto3.client('s3')
    obj = s3.get_object(Bucket=bucket, Key=key)
    
    # 获取流对象
    stream = obj['Body']
    
    # 逐行读取，处理一行，yield 一行
    for line in stream.iter_lines():
        if line:
            # 假设做一些预处理
            processed_data = line.decode('utf-8').strip()
            # 这里的 yield 极其关键：
            # 它让 DataLoader 可以拿走这一条数据去训练，
            # 而不是等整个文件下载完
            yield processed_data

# 在 Dataset 中使用
class MyMinIODataset(IterableDataset):
    def __iter__(self):
        return stream_lines_from_minio('my-bucket', 'train.csv')
```

---

### 4. 进阶：`yield from` (Python 3.3+)

如果你在一个生成器里，需要调用另一个生成器，以前需要写循环，现在可以用 `yield from`。

```Python
def sub_gen():
    yield 1
    yield 2

def main_gen():
    yield 'Start'
    # 相当于把 sub_gen 的产出直接接管过来
    yield from sub_gen() 
    yield 'End'

# list() 会自动循环调用 next() 直到结束
print(list(main_gen()))
# 输出: ['Start', 1, 2, 'End']
```

### 总结

1. **定义：** `yield` 把函数变成了生成器。
    
2. **机制：** 它是**暂停点**，保留函数当前的局部变量和执行位置。
    
3. **用途：** 处理**大数据流**、无限序列，或者构建高效的数据管道（Pipeline）。
    

下一步：

既然你理解了 yield，在你的 IterableDataset 实现中，记得在 __iter__ 方法里直接写 yield 逻辑，或者调用一个包含 yield 的函数，这能最大化减少你的训练预处理内存开销。需要我帮你写一个结合 yield 和 MinIO 的完整 Dataset 类吗？
## 函数

### 可读性

```python

def connect_server(host: str, port: int) -> bool:
    """
    建立与远程服务器的连接。

    Args:
        host (str): 服务器的 IP 地址或域名 (例如 '192.168.1.5')。
        port (int): 服务端口号，通常在 1024-65535 之间。

    Returns:
        bool: 如果连接成功返回 True，否则返回 False。

    Raises:
        ConnectionError: 当网络不可达时抛出。
    """
    # 你的代码逻辑
    return True

```