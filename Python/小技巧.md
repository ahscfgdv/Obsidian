## 注释大量代码

```python

import sys

sys.exit(0)
...
...
...

之后的代码不在执行

```

## python -m

在 Python 开发中，`python -m <module_name>` 是一个非常强大且常用的命令。简单来说，它的作用是**将一个模块或包作为脚本运行**。

相比于直接运行文件路径（`python app/test/crud.py`），`-m` 带来的核心差异在于它处理**搜索路径（sys.path）**和**包结构（Package Structure）**的方式。

---

### 1. 核心作用：自动添加当前目录到路径

当你使用 `python -m` 时，Python 会自动将**当前执行命令的目录（Current Working Directory）**添加到 `sys.path` 的最前面。

- **直接运行文件**：`python path/to/script.py` 会将 `script.py` 所在的目录加入路径。
    
- **使用 -m 运行**：`python -m path.to.script` 会将你**终端当前所在的目录**加入路径。
    

**这就是为什么你之前的报错消失了：** 因为你身处 `server/` 目录，`-m` 让 Python 找到了 `server/` 目录下的 `app` 包；而直接运行子目录脚本时，Python 只会在 `app/test/` 内部找，自然找不到外层的 `app` 模块。

---

### 2. 维持包的“身份”（Relative Imports）

如果你在代码中使用了**相对导入**（例如 `from ..db import session`），直接运行脚本文件通常会报错：`ImportError: attempted relative import with no known parent package`。

使用 `python -m` 可以让 Python 意识到该文件是一个大包（Package）的一部分，从而正确解析这些相对路径。它会根据点分隔符（`.`）来确定父级包的关系。

---

### 3. 运行内置的标准库工具

许多 Python 内置工具和第三方库并不提供全局的命令行指令，而是通过 `-m` 来调用。这是它最常见的用途之一：

- **搭建临时 HTTP 服务器**（用于快速共享文件）：
    
    `python -m http.server 8000`
    
- **压缩/解压文件**：
    
    `python -m zipfile -l test.zip`
    
- **性能分析（Profiler）**：
    
    `python -m cProfile my_script.py`
    
- **创建虚拟环境**：
    
    `python -m venv .venv`
    
- **JSON 格式化**：
    
    `echo '{"name":"gemini"}' | python -m json.tool`
    

---

### 4. 它是如何工作的？（`__main__.py` 的秘密）

当你对一个**文件夹（包）**执行 `-m` 命令时（例如 `python -m my_package`），Python 会去该文件夹下寻找一个名为 **`__main__.py`** 的文件。

- 如果存在，就执行它。
    
- 如果不存在，就会报错说该目录无法作为脚本运行。
    

这就是为什么 `pip` 或 `uv` 可以通过 `python -m pip` 运行——因为它们的源码包里都有一个 `__main__.py` 作为入口。

---

### 总结：何时该用 `-m`？

|**场景**|**建议方式**|**原因**|
|---|---|---|
|运行简单的**独立脚本**|`python script.py`|简单直接|
|在大型项目里运行**某个模块**|`python -m app.test.crud`|**必选**。能正确处理 `app` 包的导入路径|
|调用 **pip, venv, pytest** 等工具|`python -m pytest`|**更安全**。确保使用的是当前 Python 环境下的工具，避免版本混淆|

**既然你已经成功运行了 `crud.py`，接下来是想根据你的 `User` 模型写几个测试数据进去，还是想继续完善 FastAPI 的接口逻辑？**